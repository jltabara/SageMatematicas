{"name":"Sagematematicas","tagline":"Libro introductorio al manejo del Programas Sagemath","body":"# Aritmética Básica\r\n\r\n\r\nSuele denominarse Aritmética  al estudio de las operaciones con números enteros. Nosotros entenderemos por Aritmética también el estudio de las operaciones con otros tipos de números, como pueden ser los racionales, los reales y los complejos.\r\n\r\n\r\n## Operaciones con enteros\r\n\r\n\r\nLas operaciones con enteros se realizan en Sage con los operadores habituales y son siempre exactas, no empleando nunca aproximaciones. El uso de paréntesis es similar al que se realiza en matemáticas, así como la jerarquía de operaciones.\r\nLos espacios en blanco entre los operadores y los números son innecesarios. Solamente se usan para facilitar la lectura. \r\n\r\n```\r\nsage: # Todo lo que aparece tras el signo # es un comentario\r\nsage: 45 + 89\r\n134\r\nsage: 48 - 963\r\n-915\r\nsage: 125 * 56\r\n7000\r\nsage: 4 + 7 * 12 # Jerarquia habitual de operaciones\r\n88\r\nsage: (4 + 7) * 12 # Parentesis y cambio de la jerarquia\r\n132\r\nsage: 125/5 # Una division exacta. Resultado entero\r\n25\r\nsage: 45/23  # Si la division no es exacta tenemos un numero racional\r\n45/23\r\nsage: 190/24  # Si la fraccion es reducible, Sage la reduce\r\n95/12\r\n```\r\n\r\nPara calcular potencias se emplea el circunflejo (o el doble asterisco) y Sage utiliza precisión infinita. Los exponentes negativos dan lugar a fracciones.\r\n\r\n```\r\nsage: # Podemos escribir dos o mas operaciones separadas por punto y coma\r\nsage: 2^34; 2**34\r\n17179869184\r\n17179869184\r\nsage: # Tambien se pueden separar por comas, y el resultado aparece \r\nsage: # en forma de lista, esto es, entre parentesis\r\nsage: 2^34, 2**34\r\n(17179869184, 17179869184)\r\nsage: 2**400 # Precision infinita\r\n2582249878086908589655919172003011874329705792829223512830\r\n6593565406476220168411946296453532801378314359031719727474\r\n93376\r\nsage: 2^(-4)  # Las potencias de exponente negativo producen fracciones\r\n1/16\r\nsage: a = 3  # Las variables se inicializan con el signo =\r\nsage: 2*a, a^2, 3*a - 2\r\n(6, 9, 7)\r\n```\r\n\r\n##Operaciones con números racionales y reales\r\n\r\n\r\nLas fracciones se escriben en la forma habitual, con la barra de división. Si en una operación aparecen fracciones y números enteros, el resultado será siempre una fracción o un número entero.\r\n\r\n```\r\nsage: 4/7 + 8/3 \r\n68/21\r\nsage: 3/5 - 6/11\r\n3/55\r\nsage: (3/4 - 4/5)^3 + (2/3) / (34/89)\r\n711949/408000\r\n```\r\n\r\nLos números reales se escriben con el punto decimal. Si queremos escribirlos en notación científica, el exponente de la potencia de 10 se escribe tras la letra `e`. Si en una operación aparece un número decimal, el resultado proporcionado por Sage es también un número decimal. **Al trabajar con decimales Sage emplea aritmética no exacta y puede que algunos cálculos no sean correctos**.\r\n\r\n```\r\nsage: 1.563 + 3.89\r\n5.45300000000000\r\nsage: 1.456e25 / 2.456e-12\r\n5.92833876221498e36\r\nsage: (1.123782)^100\r\n117005.737177117\r\nsage: 4/5 + 0.87\r\n1.67000000000000\r\nsage: 91./23 # Basta un punto y da el resultado en decimales\r\n3.95652173913043\r\n```\r\n\r\nLa raíz cuadrada se calcula con la función `sqrt()`. Para calcular la raíz $n$-ésima elevamos a  $1/n$. Sage simplifica radicales, extrayendo factores siempre que es posible, cuando los números son enteros o racionales. Si el número al que se le calcula el radical es un número con decimales, nos da la respuesta con decimales.\r\n\r\n```\r\nsage: sqrt(4), sqrt(8), sqrt(32) # Extraccion de factores\r\n(2, 2*sqrt(2), 4*sqrt(2))\r\nsage: sqrt(32/27) # Extraccion de factores en fracciones\r\n4/3*sqrt(2/3)\r\nsage: 1024^(1/4) # La raiz cuarta extrayendo factores\r\n4*4^(1/4)\r\nsage: 1024^(1/7) # La raiz septima\r\n2*8^(1/7)\r\nsage: 1024.0^(1/7) # Ahora el numero es decimal\r\n2.69180038526471\r\nsage: sqrt(32.)\r\n5.65685424949238\r\n```\r\n\r\nEn Matemáticas existen distintos conjuntos numéricos. Tenemos el conjunto de los números enteros, denotado por $\\mathbb{Z}$, el conjunto de los números racionales $\\mathbb{Q}$, etc. En Sage hay algo similar, aunque no totalmente igual: en $\\mathbb{Z}$ y en $\\mathbb{Q}$ el programa utiliza aritmética exacta, sin embargo en $\\mathbb{R}$ y en $\\mathbb{C}$  utiliza aritmética aproximada, por lo que pueden producirse errores. El conjunto de los enteros se denota en el programa por `ZZ`. Los racionales, los reales y los complejos se denotan `QQ`, `RR` y `CC`. Para saber en que conjunto considera Sage que está cada número utilizamos el método\r\n\r\n`.base_ring()`\r\n\r\naunque también se puede utilizar la función\r\n\r\n`type()`\r\n\r\nLa diferencia entre método y función es su forma de utilización.  Para usar una función escribimos el nombre de la función y entre paréntesis el objeto al que se le aplica la función. Sin embargo para utilizar un método, primero escribimos el objeto sobre el que va a actuar, después escribimos un punto y finalmente el método. \r\n\r\nPara saber si un número pertenece a un conjunto numérico, empleamos el operador `in`. Si la respuesta es `True` el número pertenece al conjunto. Si retorna `False` no pertenece al conjunto.\r\n\r\n```\r\nsage: a = 2\r\nsage: a.base_ring()\r\nInteger Ring\r\nsage: type(a)\r\n<type 'sage.rings.integer.Integer'>\r\nsage: # El comando ``in'' se utiliza como el simbolo pertenece\r\nsage: a in ZZ, a in QQ, a in RR, a in CC\r\n(True, True, True, True)\r\nsage: a = 3/7\r\nsage: a.base_ring()\r\nRational Field\r\nsage: type(a)\r\n<type 'sage.rings.rational.Rational'>\r\nsage: a in ZZ, a in QQ, a in RR, a in CC\r\n(False, True, True, True)\r\nsage: a = 1.53876\r\nsage: a.base_ring()\r\nReal Field with 53 bits of precision\r\nsage: type(a)\r\n<type 'sage.rings.real_mpfr.RealLiteral'>\r\nsage: a in ZZ, a in QQ, a in RR, a in CC\r\n(False, True, True, True)\r\nsage: # El numero decimal tambien es un numero racional\r\nsage: a = sqrt(2) # Un numero irracional\r\nsage: a in ZZ, a in QQ, a in RR, a in CC\r\n(False, False, True, True)\r\n```\r\n\r\nPara obtener aproximaciones decimales utilizamos la función (y a la vez método)\r\n\r\n`n()`\r\n\r\nEsta función admite como opción `digits` para obtener las aproximaciones con distinto número de cifras.\r\n\r\n```\r\nsage: n(sqrt(2))   # Precision por defecto\r\n1.41421356237310\r\nsage: n(sqrt(2), digits=50)  # Mayor precision\r\n1.4142135623730950488016887242096980785696718753769\r\nsage: n(sqrt(2), digits=5)\r\n1.4142\r\nsage: sqrt(2).n()  # Actuando como metodo\r\n1.41421356237310\r\nsage: sqrt(2).n(digits=30)  # El modificador digits como metodo\r\n1.41421356237309504880168872421\r\n```\r\n\r\n\r\nPara extraer el denominador y el numerador de un número racional (simplificados)\r\n\r\n`.denominator()`, `.numerator()`\r\n\r\n```\r\nsage: a = 770/230\r\nsage: denominator(a)\r\n23\r\nsage: a.denominator(). \r\n23\r\nsage: a.numerator()\r\n77\r\nsage: a = -74/21\r\nsage: a.numerator(), a.denominator()\r\n(-74, 21)\r\n```\r\n\r\nLos números reales se pueden aproximar a los enteros de distintos modos. La forma más habitual es el redondeo, que devuelve el número entero más próximo al número decimal en cuestion. Pero también podemos redondear por defecto y por exceso. Los comandos para realizar todos estos tipos de redondeo son\r\n\r\n`.round()`, `.floor()`, `.ceil()`\r\n\r\n\r\nEstas 5 instrucciones se pueden utilizar como funciones o como métodos. La función `.round()` admite una opción, que nos sirve para especificar  con cuantos decimales queremos el redondeo. Incluso admite números negativos, si queremos redondear a las decenas, centenas, ... Sin embargo esto solamente funciona si utilizamos la función y no sirve con el método.\r\n\r\n```\r\nsage: a = 3.67\r\nsage: a.round(), a.floor(), a.ceil()\r\n(4, 3, 4)\r\nsage: a = 3.234\r\nsage: a.round(), a.floor(), a.ceil()\r\n(3, 3, 4)\r\nsage: a = -3.898\r\nsage: a.round(), a.floor(), a.ceil()\r\n(-4, -4, -3)\r\nsage: a = 3456.876543\r\nsage: round(a), round(a,2), round(a,5)\r\n(3457, 3456.88, 3456.87654)\r\nsage: round(a,-1), round(a,-2), round(a,-4)\r\n(3460.0, 3500.0, 0.0)\r\n```\r\n\r\n\r\n## La ayuda en Sage\r\n\r\nLa notación de función es más intuitiva y más próxima al hacer matemático. Sin embargo los métodos tienen una ventaja adicional:  como primero debemos escribir el objeto, Sage ya \"sabe\" qué métodos se pueden aplicar a dicho objeto. Si escribimos un objeto y el punto y pulsamos el tabulador, el programa nos muestra un menú con los métodos que se pueden aplicar a dicho objeto. Si hemos empezado a escribir el método y pulsamos el tabulador, el programa completa la escritura, o en caso de que haya varios métodos que comiencen por dichas letras nos da las alternativas. Por esta razón nosotros potenciaremos la utilización de métodos.\r\n\r\nPara obtener ayuda sobre un método o función, en vez de escribir los paréntesis, escribimos el signo de interrogación `?` y pulsamos Enter. Si la ayuda ocupa más de una pantalla la barra  espaciadora nos permite avanzar página.  Para salir de la ayuda debemos pulsar la tecla `q` (del inglés *quit*).  Puede ocurrir que gran parte de la ayuda sea incomprensible para nosotros, pero hay una parte de texto (eso si, en inglés) y ejemplos de uso que nos pueden ser de utilidad.\r\nSi en vez de escribir el signo de interrogación escribimos dos signos de interrogación, el programa nos informa del código fuente de la función. En principio esto sólo tiene utilidad para una utilización más avanzada de Sage que la que proponemos en estas notas.\r\n\r\nEn el siguiente código hemos borrado la salida por ser demasiado larga. Si escribimos `[Tab]` significa que debemos pulsar el tabulador y si escribimos `[Enter]` debemos pulsar dicha tecla.\r\n\r\n```\r\nsage: # Veamos que metodos se pueden aplicar a un numero racional\r\nsage: a = 7/3\r\nsage: a.[Tab]\r\n\t  # salida eliminada       \r\nsage: # Ahora los metodos que empiezan por d\r\nsage: a.d[Tab]\r\n\t  # salida eliminada   \r\nsage: # Pedimos ayuda sobre metodo denominator\r\nsage: a.denominator?[Enter]\r\n\t  # salida eliminada \r\nsage: # Ahora las funciones que empiezan por j\r\nsage: j[Tab]\r\n\t  # salida eliminada \r\n```\r\n\r\n\r\n\r\n## Comparación de números\r\n\r\nLos operadores de orden son\r\n\r\n`<`,  `>`,  `<=`,  `>=`\r\n\r\nCuando comparamos dos números con uno de estos operadores, la respuesta es `True`, si la desigualdad es verdadera y `False` en caso contrario.\r\n\r\nAdemás de los operadores de orden, tenemos los operadores\r\n\r\n`==`, `!=`\r\n\r\n\r\nEl primero devuelve `True` cuando los dos números que comparamos son iguales. En cambio el segundo operador devuelve `True` cuando ambos son distintos.\r\n\r\n```\r\nsage: 5 < 6\r\nTrue\r\nsage: -5 > 6\r\nFalse\r\nsage: 78 < 78, 78 <= 78\r\n(False, True)\r\nsage: # El signo de comparacion es == y no =\r\nsage: 45 == 9 * 5\r\nTrue\r\nsage: 78 != 78\r\nFalse\r\nsage: # En vez del simbolo != tambien se puede emplear <>\r\nsage: 78 <> 78, 78 <> 123\r\n(False, True)\r\n```\r\n\r\n## División euclídea\r\n\r\nEn el conjunto de los números enteros existe el concepto de *división euclídea*.  Dados dos números enteros arbitrarios $a$, $b$ podemos encontrar dos números, únicos, $c$ y $r$ que verifican:\r\n\r\n- $a=b\\cdot c+r$.\r\n\r\n- $r$ es un entero positivo o nulo, menor que $|b|$.\r\n\r\n\r\nPara obtener el cociente de la división de $n$ entre $m$ se emplean el comando\r\n\r\n`//`\r\n\r\nPara obtener el resto se pueden emplear dos formas alternativas\r\n\r\n`.mod()`, `%`\r\n\r\n```\r\nsage: 23 // 5 # Cociente\r\n4\r\nsage: 23 % 5 # Resto\r\n3\r\nsage: # Comprobemos\r\nsage: 4 * 5 + 3\r\n23\r\nsage: # Tambien funciona con numeros negativos\r\nsage: -26 // 5\r\n-6\r\nsage: -26 % 5\r\n4\r\nsage: -6 * 5 + 4\r\n-26\r\nsage: # Lo mismo lo podemos realizar con el metodo mod\r\nsage: (-26).mod(5)\r\n4\r\nsage: mod(-26, 5) # Como funcion de dos argumentos\r\n4\r\nsage: # El quinto numero de Fermat es\r\nsage: 2^(2^5) + 1\r\n4294967297\r\nsage: # Fermat pensaba que era primo. Sin embargo Euler comprobo que\r\nsage: 4294967297 % 641\r\n0\r\n```\r\n\r\n\r\n## Primos y factorización\r\n\r\nUn número natural es *primo* si sus únicos divisores (positivos) son la unidad y él mismo.  Los números que no son primos se denominan *compuestos*. Para ellos rige el *Teorema Fundamental de la Aritmética*, que afirma que todo número compuesto admite una factorización (única salvo el orden) en producto de primos.\r\n\r\nLa comprobación de que un número es primo es un problema computacionalmente costoso.  Por ello muchas veces (sobre todo para enteros \"muy\"  grandes) se hace un análisis probabilístico para verificar si un número es primo.  Aún peor, desde el punto de vista computacional, es el problema de la factorización. Por ello solo debemos esperar de  Sage resultados para enteros \"razonables\".\r\n\r\nPara saber si un número es primo debemos emplear el método\r\n\r\n`.is_prime()`\r\n\r\nSage también puede informarnos si un número es una potencia de un número primo\r\n\r\n`.is_prime_power()`\r\n\r\nDado un número entero $n$, el primer número mayor que $n$ y primo\r\n\r\n`.next_prime()`\r\n\r\nAnálogamente el primo inmediatamente anterior a $n$\r\n\r\n`.previous_prime()`\r\n\r\nLos siguientes métodos se expresan por si mismos\r\n\r\n`.next_prime_power()`, `previous_prime_power()`\r\n\r\n```\r\nsage: a = 89; a.is_prime()\r\nTrue\r\nsage: 81.is_prime_power()  # Sabemos que 81 = 3^4\r\nTrue\r\nsage: 100.is_prime_power()  # Sin embargo 100 = 2^2*5^2\r\nFalse\r\nsage: 9.next_prime()\r\n11\r\nsage: previous_prime(16)\r\n13\r\nsage: next_prime_power(14)\r\n16\r\nsage: previous_prime_power(90)\r\n89\r\nsage: # Efectivamente, puesto que 89 = 89^1\r\n```\r\n\r\nCuando el número es compuesto podemos estar interesados en obtener su descomposición en factores primos\r\n\r\n`.factor()`\r\n\r\nMuy relacionado con el problema de la factorización, se encuentra el problema de hallar todos los divisores de un número dado. Multiplicando cualesquiera factores de la descomposición de un número obtenemos un divisor de dicho número. Es más, cualquier divisor se puede obtener de ese modo. Para obtener una lista con todos los divisores de un número\r\n\r\n`.divisors()`\r\n\r\n```\r\nsage: 360.factor()\r\n2^3 * 3^2 * 5\r\nsage: # Comprobemos que es correcto\r\nsage: 2^3 * 3^2 * 5\r\n360\r\nsage: 180.divisors() \r\n[1, 2, 3, 4, 5, 6, 9, 10, 12, 15, 18, 20, 30, 36, 45, 60, 90, 180]\r\n```\r\n\r\n\r\n## Máximo común divisor y Mínimo común múltiplo\r\n\r\nDado un entero $n$ consideramos el conjunto de sus divisores positivos. Ciertamente este es un conjunto finito contenido en $\\mathbb{N}$. Dado otro número $m$ consideramos nuevamente el conjunto de sus divisores. Hacemos la intersección de ambos conjuntos, que es necesariamente no vacía puesto que la unidad divide a todo número.  El mayor de los números de dicha intersección es, por definición, el máximo común divisor de ambos números.  Esta es la definición clásica de este concepto. \r\n\r\nAhora consideramos los múltiplos positivos de $n$ y los de $m$. Hacemos la intersección de dichos conjuntos. Dicha intersección es no vacía, puesto que $nm$ está en ambos conjuntos. De todos los elementos de dicha intersección debe existir uno que sea el menor de todos (necesariamente es menor o igual que $nm$). Dicho número es el mínimo común múltiplo.\r\n\r\n\r\nPara calcular el máximo común divisor de dos enteros (*greatest common divisor* en inglés)\r\n\r\n`.gcd()`\r\n\r\nEl mínimo común múltiplo (*least common multiple* en inglés)\r\n\r\n`.lcm()`\r\n\r\n\r\n```\r\nsage: (78).gcd(24)\r\n6\r\nsage: (78).lcm(24)\r\n312\r\nsage: # El producto del minimo por el maximo da el producto de los numeros\r\nsage: 6 * 312, 78 * 24\r\n(1872, 1872)\r\n```\r\n\r\n##Números complejos\r\n\r\nLos números complejos son expresiones de la forma $a+bi$ donde $a$ y $b$ son números reales e $i$ es una raíz cuadrada de $-1$ (o lo que es lo mismo, $i^2 = -1$).  Por defecto Sage reconoce a la letra  `i` como un objeto simbólico con la propiedad $i^2 = -1$. Muchos cálculos los puede realizar directamente, pero en algunos casos es necesario comenzar el cálculo con números complejos con la instrucción `i = CC(i)` (no es necesario conocer ahora el significado de esta orden)\r\n\r\n\r\n```\r\nsage: type(i)\r\n<type 'sage.symbolic.expression.Expression'>\r\nsage: type(3 + 4*i)\r\n<type 'sage.symbolic.expression.Expression'>\r\nsage: i.base_ring()\r\nSymbolic Ring\r\nsage: i^2\r\n-1\r\n```\r\n\r\nLas operaciones aritméticas se realizan nuevamente con los operadores habituales.  En las respuestas de Sage la unidad imaginaria se escribe en mayúsculas. Las operaciones con números complejos se realizan en aritmética aproximada, por lo que son susceptibles a errores. Además el número de decimales que da el programa puede hacer difícil la lectura del resultado.\r\n\r\n```\r\nsage: a = 5 + 8*i\r\nsage: b = 3.4 + 9*i\r\nsage: a + b\r\n8.40000000000000 + 17.0000000000000*I\r\nsage: 3*a + 8.9*b\r\n45.2600000000000 + 104.100000000000*I\r\nsage: a - b\r\n1.60000000000000 - 1.00000000000000*I\r\nsage: a * b\r\n-55.0000000000000 + 72.2000000000000*I\r\nsage: a / b\r\n0.961538461538461 - 0.192307692307692*I\r\nsage: a^5\r\n25525.0000000000 - 70232.0000000000*I\r\n```\r\n\r\nDado el número complejo $z=a+bi$ su parte real es $a$ y su parte imaginaria es $b$. Para obtenerlas utilizamos los métodos\r\n\r\n`.real()`, `.imag()`\r\n\r\nEl módulo o valor absoluto es $\\sqrt{a^2 + b^2}$\r\n\r\n`.abs()`\r\n\r\nEl conjugado es $a-bi$\r\n\r\n`.conjugate()`\r\n\r\nLa norma de un número complejo se obtiene multiplicando dicho número por su complejo conjugado.  Es siempre un número real, que resulta coincidir con $a^2+b^2$\r\n\r\n`.norm()`\r\n\r\nSi imaginamos el número complejo $z= a+bi$ como el vector $(a,b)$, dicho vector forma con la parte positiva del eje de las $x$ un cierto ángulo.  Es el denominado argumento del número complejo (Sage lo mide en radianes)\r\n\r\n`.arg()`, `.argument()`\r\n\r\n```\r\nsage: a = 5 + 8*i\r\nsage: a.real()\r\n5\r\nsage: a.imag()\r\n8\r\nsage: a.abs()\r\nsqrt(89)\r\nsage: a.norm()\r\n89\r\nsage: a.conjugate()\r\n-8*I + 5\r\nsage: # El metodo  arg() no funciona sin hacer i = CC(i)\r\nsage: i = CC(i)\r\nsage: a = 5 + 8*i\r\nsage: a.arg()\r\n1.01219701145133\r\nsage: a.abs() # Ahora da las soluciones con decimales\r\n9.43398113205660\r\nsage: sqrt(89).n()\r\n9.43398113205660\r\n```\r\n\r\nComo consecuencia del *Teorema Fundamental del Álgebra* todo número complejo tiene exactamente $n$ raíces $n$-ésimas (pues el polinomio $x^n - a$ debe tener $n$ soluciones). Para conocerlas utilizamos\r\n\r\n`.nth_root(n)`\r\n\r\ndonde debemos indicar como argumento el orden de la raíz deseada. Por defecto Sage solamente nos devuelve una de las raíces.  Si utilizamos la opción `all = True` nos devuelve una lista con todas las raíces.  Para el caso de la raíz cuadrada se puede utilizar `sqrt()`.\r\n\r\n```\r\nsage: i = CC(i)\r\nsage: a = 4.6 + 9.68*i\r\nsage: b = a.nth_root(5); b\r\n1.56634459784419 + 0.359216283265026*I\r\nsage: b^5\r\n4.59999999999999 + 9.68000000000000*I\r\nsage: a.nth_root(5, all = True)\r\n[1.56634459784419 + 0.359216283265026*I,\r\n 0.142392112822719 + 1.60068617272853*I,\r\n -1.47834143238984 + 0.630062176803190*I,\r\n -1.05605736501685 - 1.21128633243841*I,\r\n 0.825662086739775 - 1.37867830035833*I]\r\nsage: sqrt(a)\r\n2.76743452871272 + 1.74891219639849*I\r\nsage: sqrt(a, all = True)\r\n[2.76743452871272 + 1.74891219639849*I,\r\n -2.76743452871272 - 1.74891219639849*I]\r\n```\r\n\r\n## Miscelánea\r\n\r\n\r\nNormalmente los números se escriben en base 10, pero se pueden expresar en otras bases. Sage está especialmente preparado para esta circunstancia. Si escribimos un número entero que comience por `0`, Sage entenderá que es un número escrito en el sistema octal. Si el número empieza por `0x` entiende que es un número escrito en hexadecimal. Para transformar un número a otra base $b$ (necesariamente menor que 36, que es la suma de las diez cifras y las 26 letras) se emplea el método\r\n\r\n`.str(b)`\r\n\r\n```\r\nsage: 10, 11, 12 # decimal\r\n(10, 11, 12)\r\nsage: 010, 011, 012 # octal\r\n(8, 9, 10)\r\nsage: 0x10, 0x11, 0x12 # hexadecimal\r\n(16, 17, 18)\r\nsage: 03456 + 0x23a # Se pueden mezclar. Resultado en decimal\r\n2408\r\nsage: 348.str(2)\r\n'101011100'\r\nsage: 348.str(23)\r\n'f3'\r\n```\r\n\r\n\r\nLa factorial de un número entero positivo es el producto de todos los números enteros positivos menores o iguales que el dado\r\n\r\n`.factorial()`\r\n\r\nLa sucesión de Fibonacci es $1,1,2,3,5,8, \\dots$. Los dos primeros términos son la unidad. Los siguientes se obtienen sumando los dos anteriores. Para conocer el término $n$-ésimo de la sucesión\r\n\r\n`fibonacci()`\r\n\r\nEn una sección anterior hemos dado la definición más elemental del concepto de máximo común divisor. Sin embargo muchas veces es más útil utilizar la siguiente. Dados dos enteros $p$ y $q$, consideremos todos los números naturales que se pueden expresar en la forma $np+mq$, siendo $n$ y $m$ números enteros arbitrarios. El elemento mínimo de dicho conjunto coincide con el máximo común divisor. Además del máximo común divisor $d$, muchas veces es necesario conocer una pareja de números enteros $n,m$ que cumplan $np+mq=d$. En esencia lo comentado anteriormente es el conocido *Lema de Bezout*. Para obtener todo empleamos el comando\r\n\r\n`.xgcd()`\r\n\r\n```\r\nsage: 4.factorial(), factorial(4), factorial(5), 5*factorial(4)\r\n(24, 24, 120, 120)\r\nsage: fibonacci(6), fibonacci(7), fibonacci(8)\r\n(8, 13, 21)\r\nsage: xgcd(78,24)\r\n(6, 9, -29)\r\nsage: 9*78 + (-24)*29\r\n6\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}