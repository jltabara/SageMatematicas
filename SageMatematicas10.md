# Grupos abelianos finitos

Un {\sf grupo cíclico} es aquel generado por un solo elemento. Para cualquier número natural $n$, existe un único (salvo isomorfismos) grupo cíclico de orden $n$, que denotaremos $C_n$. Dicho grupo es isomorfo al grupo aditivo $\Z_n$.  Además de estos grupos finitos existe un grupo cíclico infinito, $C_\infty$, que es isomorfo a $\Z$. Naturalmente todo grupo cíclico es abeliano. También es claro que todo producto directo de grupos cíclicos es abeliano. El {\sf Teorema de estructura de los grupos abelianos finitos} afirma esto agota el conjunto de grupos abelianos finitos: Todo grupo abeliano finito es isomorfo a un producto directo de grupos cíclicos.



El comando 

`G.<a,b,c> = AbelianGroup([n,m,k])`

crea un grupo abeliano, de nombre `G`, isomorfo a $C_n \times C_m \times C_k$. El generador de $C_n$ es `a`, el de $C_m$ es `b` y el de $C_k$  es `c`. La misma construcción se puede realizar con cualquier número de grupos cíclicos.  Todo elemento del grupo se puede escribir como producto de potencias de los generadores. La operación en el grupo se realiza con el asterisco. Escribiendo un único elemento en la lista construimos los grupos cíclicos.

Dado un grupo, el método


`.list()`

nos da una lista con todos los elementos del grupo.

Si solamente queremos saber cuantos  elementos tiene el grupo podemos utilizar


`.order()`


El programa puede extraer, de modo aleatorio, un elemento del grupo 


`.random_element()`



```
sage: G.<a,b> = AbelianGroup([2,3]); G
Multiplicative Abelian Group isomorphic to C2 x C3
sage: G.order()
6
sage: G.list()
[1, b, b^2, a, a*b, a*b^2]
sage: G.<a,b,c> = AbelianGroup([67,980,23]); G
Multiplicative Abelian Group isomorphic to C67 x C980 x C23
sage: h = G.random_element(); h
a^10*b^449*c^22
sage: g = G.random_element(); g
a^62*b^391*c^20
sage: h * g, g * h  # Deben conmutar
(a^5*b^840*c^19, a^5*b^840*c^19)
sage: i = g^(-1); i
a^5*b^589*c^3
sage: i * g
1
```

Para crear un subgrupo $H$ de un grupo $G$ basta con dar una lista de generadores del subgrupo. Esto es, si damos una lista de elementos del grupo, el subgrupo generado es el mínimo subgrupo que contiene a todos los elementos. En {\sf Sage} se utiliza el método


`.subgroup(lista)`


donde `lista` es una lista (y por lo tanto debe ir entre corchetes, aunque tenga un solo elemento) de generadores del subgrupo.

Dado un elemento $g$ del grupo $G$, dicho elemento genera un subgrupo. Como estamos suponiendo que $G$ es finito, el subgrupo generado por $g$ también debe serlo. Al número de elementos de este subgrupo (también llamado orden del subgrupo) se le denomina *orden* del elemento $g$.  Coincide con el menor entero positivo que cumple la igualdad $g^n =1$, que es la definición clásica de este concepto. El método para saber el orden de un elemento es


`.order()`


pero en este caso debe actuar sobre un elemento del grupo.

```
sage: G.<a,b,c,d> = AbelianGroup([45,78,23,678]); G
Multiplicative Abelian Group isomorphic to C45 x C78 x C23 x C678
sage: g = G.random_element()
sage: h = G.random_element()
sage: g, h
(a^4*b^76*c^21*d^548, a^22*b^75*c^17*d^129)
sage: H = G.subgroup([a,b]); H

Multiplicative Abelian Group isomorphic to C2 x C3 x C5 x C9 x C13,
which is the subgroup of
Multiplicative Abelian Group isomorphic to C45 x C78 x C23 x C678
generated by [a, b]
sage: Hg = G.subgroup([g])
sage: Hg.order(), g.order()
(1520415, 1520415)
```

## Grupos finitos


Históricamente los primeros ejemplos de grupos finitos estuvieron asociados al estudio de las raices de polinomios y surgieron de la mente de Galois. Galois consideraba el conjunto de todas las raíces de un polinomio de coeficientes racionales. Este es un conjunto finito de números complejos. Posteriormente consideraba algunas permutaciones de este conjunto, de tal forma que la composición de dos permutaciones fuera otra de las permutaciones permitida. Hacia la mitad del siglo 10 Cayley dio la definición, en términos modernos, de lo que es un grupo abstracto. Sin embargo el mismo Cayley demostró que todo grupo es isomorfo a un subgrupo de un grupo simétrico. Este es el contenido del famoso {\sf Teorema de Cayley}. Por ello, a nivel operativo, y en el estudio de los grupos finitos, podemos considerar únicamente grupos formados por permutaciones (o lo que es lo mismo, subgrupos del grupo simétrico).

Para construir el grupo simétrico de $n$ letras


`SymmetricGroup(n)`


Los elementos del grupo simétrico son permutaciones, las  cuales pueden ser pares o impares. El conjunto de permutaciones pares es un subgrupo del grupo simétrico y se construye con el comando


`AlternatingGroup(n)`



Naturalmente dicho grupo es isomorfo a $C_n$.

Consideremos ahora un polígono regular de $n$ lados. Consideramos las rotaciones de dicho polígono. El conjunto de dichas rotaciones forman un grupo cíclico, isomorfo a $C_n$ y lo podemos crear con el comando



`CyclicPermutationGroup(n)`


Si ahora consideramos todas los movimientos (por lo que se permiten las inversiones) que dejan fijo al polígono regular. Este nuevo conjunto es un grupo, llamado grupo dihedral


`DihedralGroup(n)`
